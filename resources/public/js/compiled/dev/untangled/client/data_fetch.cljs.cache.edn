;; Analyzed by ClojureScript 1.8.51
{:use-macros {tr untangled.i18n}, :excludes #{}, :name untangled.client.data-fetch, :imports nil, :requires {impl untangled.client.impl.data-fetch, dom om.dom, om.dom om.dom, untangled.i18n untangled.i18n, untangled.client.core untangled.client.core, untangled.client.impl.data-fetch untangled.client.impl.data-fetch, util om.util, om om.next, om.next om.next, clojure.walk clojure.walk, uc untangled.client.core, om.util om.util}, :uses {walk clojure.walk, prewalk clojure.walk}, :defs {failed? {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 251, :column 7, :end-line 251, :end-column 14, :arglists (quote ([state]))}, :name untangled.client.data-fetch/failed?, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 14, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 251, :end-line 251, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, data-state? {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 248, :column 7, :end-line 248, :end-column 18, :arglists (quote ([state]))}, :name untangled.client.data-fetch/data-state?, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 18, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 248, :end-line 248, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, ready? {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 249, :column 7, :end-line 249, :end-column 13, :arglists (quote ([state]))}, :name untangled.client.data-fetch/ready?, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 13, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 249, :end-line 249, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, load {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 47, :column 7, :end-line 47, :end-column 11, :arglists (quote ([app-or-comp-or-reconciler server-property-or-ident SubqueryClass] [app-or-comp-or-reconciler server-property-or-ident SubqueryClass config])), :doc "Load data from the server.\n\n  This function triggers a server interaction and normalizes the server response into your app state database. During\n  operation it also adds (by default) fetch markers into the app state so you can show busy indicators on the UI\n  components that are waiting for data. The `:target` parameter can be used to place the data somewhere besides app\n  state root (which is the default).\n\n  The server will receive an Om query of the form: [({server-property (om/get-query SubqueryClass)} params)], which\n  the Om parser will correctly parse as a Join on server-property with the given subquery and params. See Om AST and\n  instructions on parsing Om queries.\n\n  Parameters:\n  - `app-or-comp-or-reconciler` : An Om component instance, Untangled application, or Om reconciler\n  - `server-property-or-ident` : A keyword or ident that represents the root of the query to send to the server. If this is an ident\n  you are loading a specific entity from the database into a local app db table. A custom target will be ignored.\n  - `SubqueryClass` : An Om component that implements IQuery. This will be combined with `server-property` into a join for the server query. Needed to normalize results.\n  - `config` : A map of load configuration parameters.\n\n  Config (all optional):\n  - `target` - An assoc-in path at which to put the result of the Subquery. If supplied, the data AND load marker will appear\n    at this path. If not supplied the data and marker will appear at `server-property` in the top-level of the client app state\n    database. Ignored if you're loading via ident (the ident is your target).\n  - `params` - Optional parameters to add to the generated query\n  - `marker` - Boolean to determine if you want a fetch-state marker in your app state. Defaults to true. Add `:ui/fetch-state` to the\n  target component in order to see this data in your component.\n  - `refresh` - A vector of keywords that will cause component re-renders after the final load/mutations. Same as follow-on\n  reads in normal `transact!`\n  - `parallel` - If true, indicates that this load does not have to go through the sequential network queue. Defaults to false.\n  - `post-mutation` - A mutation (symbol) to run after the data is merged. Note, if target is supplied be sure your post mutation\n  should expect the data at the targeted location.\n  - `post-mutation-params` - An optional map  that will be passed to the post-mutation when it is called. May only contain raw data, not code!\n  - `fallback` - A mutation (symbol) to run if there is a server/network error.\n  - `without` - An optional set of keywords that should (recursively) be removed from the query.\n  ", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([app-or-comp-or-reconciler server-property-or-ident SubqueryClass] [app-or-comp-or-reconciler server-property-or-ident SubqueryClass config]), :arglists ([app-or-comp-or-reconciler server-property-or-ident SubqueryClass] [app-or-comp-or-reconciler server-property-or-ident SubqueryClass config]), :arglists-meta (nil nil)}}, :name untangled.client.data-fetch/load, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([app-or-comp-or-reconciler server-property-or-ident SubqueryClass] [app-or-comp-or-reconciler server-property-or-ident SubqueryClass config]), :arglists ([app-or-comp-or-reconciler server-property-or-ident SubqueryClass] [app-or-comp-or-reconciler server-property-or-ident SubqueryClass config]), :arglists-meta (nil nil)}, :method-params ([app-or-comp-or-reconciler server-property-or-ident SubqueryClass] [app-or-comp-or-reconciler server-property-or-ident SubqueryClass config]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 47, :end-line 47, :max-fixed-arity 4, :fn-var true, :arglists ([app-or-comp-or-reconciler server-property-or-ident SubqueryClass] [app-or-comp-or-reconciler server-property-or-ident SubqueryClass config]), :doc "Load data from the server.\n\n  This function triggers a server interaction and normalizes the server response into your app state database. During\n  operation it also adds (by default) fetch markers into the app state so you can show busy indicators on the UI\n  components that are waiting for data. The `:target` parameter can be used to place the data somewhere besides app\n  state root (which is the default).\n\n  The server will receive an Om query of the form: [({server-property (om/get-query SubqueryClass)} params)], which\n  the Om parser will correctly parse as a Join on server-property with the given subquery and params. See Om AST and\n  instructions on parsing Om queries.\n\n  Parameters:\n  - `app-or-comp-or-reconciler` : An Om component instance, Untangled application, or Om reconciler\n  - `server-property-or-ident` : A keyword or ident that represents the root of the query to send to the server. If this is an ident\n  you are loading a specific entity from the database into a local app db table. A custom target will be ignored.\n  - `SubqueryClass` : An Om component that implements IQuery. This will be combined with `server-property` into a join for the server query. Needed to normalize results.\n  - `config` : A map of load configuration parameters.\n\n  Config (all optional):\n  - `target` - An assoc-in path at which to put the result of the Subquery. If supplied, the data AND load marker will appear\n    at this path. If not supplied the data and marker will appear at `server-property` in the top-level of the client app state\n    database. Ignored if you're loading via ident (the ident is your target).\n  - `params` - Optional parameters to add to the generated query\n  - `marker` - Boolean to determine if you want a fetch-state marker in your app state. Defaults to true. Add `:ui/fetch-state` to the\n  target component in order to see this data in your component.\n  - `refresh` - A vector of keywords that will cause component re-renders after the final load/mutations. Same as follow-on\n  reads in normal `transact!`\n  - `parallel` - If true, indicates that this load does not have to go through the sequential network queue. Defaults to false.\n  - `post-mutation` - A mutation (symbol) to run after the data is merged. Note, if target is supplied be sure your post mutation\n  should expect the data at the targeted location.\n  - `post-mutation-params` - An optional map  that will be passed to the post-mutation when it is called. May only contain raw data, not code!\n  - `fallback` - A mutation (symbol) to run if there is a server/network error.\n  - `without` - An optional set of keywords that should (recursively) be removed from the query.\n  "}, load-params* {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 11, :column 7, :end-line 11, :end-column 19, :arglists (quote ([server-property-or-ident SubqueryClass {:keys [target params marker refresh parallel post-mutation post-mutation-params fallback without], :or {marker true, parallel false, refresh [], without #{}}}])), :doc "Internal function to validate and process the parameters of `load` and `load-action`."}, :name untangled.client.data-fetch/load-params*, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 19, :method-params ([server-property-or-ident SubqueryClass p__46712]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 11, :end-line 11, :max-fixed-arity 3, :fn-var true, :arglists (quote ([server-property-or-ident SubqueryClass {:keys [target params marker refresh parallel post-mutation post-mutation-params fallback without], :or {marker true, parallel false, refresh [], without #{}}}])), :doc "Internal function to validate and process the parameters of `load` and `load-action`."}, load-action {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 94, :column 7, :end-line 94, :end-column 18, :arglists (quote ([state-atom server-property-or-ident SubqueryClass] [state-atom server-property-or-ident SubqueryClass config])), :doc "\n  See `load` for descriptions of parameters and config.\n\n  Queue up a remote load from within an already-running mutation. Similar to `load`, but usable from\n  within a mutation.\n\n  Note the `:refresh` parameter is supported, and defaults to empty. If you want anything to refresh other than\n  the targeted component you will want to include the :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-action ...)\n       ; other optimistic updates/state changes)}", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([state-atom server-property-or-ident SubqueryClass] [state-atom server-property-or-ident SubqueryClass config]), :arglists ([state-atom server-property-or-ident SubqueryClass] [state-atom server-property-or-ident SubqueryClass config]), :arglists-meta (nil nil)}}, :name untangled.client.data-fetch/load-action, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([state-atom server-property-or-ident SubqueryClass] [state-atom server-property-or-ident SubqueryClass config]), :arglists ([state-atom server-property-or-ident SubqueryClass] [state-atom server-property-or-ident SubqueryClass config]), :arglists-meta (nil nil)}, :method-params ([state-atom server-property-or-ident SubqueryClass] [state-atom server-property-or-ident SubqueryClass config]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 94, :end-line 94, :max-fixed-arity 4, :fn-var true, :arglists ([state-atom server-property-or-ident SubqueryClass] [state-atom server-property-or-ident SubqueryClass config]), :doc "\n  See `load` for descriptions of parameters and config.\n\n  Queue up a remote load from within an already-running mutation. Similar to `load`, but usable from\n  within a mutation.\n\n  Note the `:refresh` parameter is supported, and defaults to empty. If you want anything to refresh other than\n  the targeted component you will want to include the :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-action ...)\n       ; other optimistic updates/state changes)}"}, load-mutation {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 38, :column 7, :end-line 38, :end-column 20, :arglists (quote ([load-args])), :doc "Generates an Om transaction expression for a load mutation. It includes a follow-on read for :ui/loading-data. The args\n  must be a map of the parameters usable from `load`. Returns a complete Om expression (vector), not just the mutation\n  since follow-on reads are part of the mutation. You may use `concat` to join this with additional expressions."}, :name untangled.client.data-fetch/load-mutation, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 20, :method-params ([load-args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 38, :end-line 38, :max-fixed-arity 1, :fn-var true, :arglists (quote ([load-args])), :doc "Generates an Om transaction expression for a load mutation. It includes a follow-on read for :ui/loading-data. The args\n  must be a map of the parameters usable from `load`. Returns a complete Om expression (vector), not just the mutation\n  since follow-on reads are part of the mutation. You may use `concat` to join this with additional expressions."}, loading? {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 250, :column 7, :end-line 250, :end-column 15, :arglists (quote ([state]))}, :name untangled.client.data-fetch/loading?, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 15, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 250, :end-line 250, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, load-field-action {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 183, :column 7, :end-line 183, :end-column 24, :arglists (quote ([app-state component-class ident field & {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]}])), :doc "Queue up a remote load of a component's field from within an already-running mutation. Similar to `load-field`\n  but usable from within a mutation. Note the `:refresh` parameter is supported, and defaults to nothing, even for\n  fields, in actions. If you want anything to refresh other than the targeted component you will want to use the\n  :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-field-action ...)\n       ; other optimistic updates/state changes)}", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(app-state component-class ident field {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]})], :arglists ([app-state component-class ident field & {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/load-field-action, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(app-state component-class ident field {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]})], :arglists ([app-state component-class ident field & {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]}]), :arglists-meta (nil)}, :method-params [(app-state component-class ident field {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 183, :end-line 183, :max-fixed-arity 4, :fn-var true, :arglists ([app-state component-class ident field & {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]}]), :doc "Queue up a remote load of a component's field from within an already-running mutation. Similar to `load-field`\n  but usable from within a mutation. Note the `:refresh` parameter is supported, and defaults to nothing, even for\n  fields, in actions. If you want anything to refresh other than the targeted component you will want to use the\n  :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-field-action ...)\n       ; other optimistic updates/state changes)}"}, lazily-loaded {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 253, :column 7, :end-line 253, :end-column 20, :arglists (quote ([data-render props & {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div (js-obj "className" "lazy-loading-load") "Loading...")), ready-render (fn [_] (dom/div (js-obj "className" "lazy-loading-ready") "Queued")), failed-render (fn [_] (dom/div (js-obj "className" "lazy-loading-failed") "Loading error!"))}}])), :doc "Custom rendering for use while data is being lazily loaded using the data fetch methods\n  load-collection and load-field.\n\n  `data-render` : the render method to call once the data has been successfully loaded from\n  the server. Can be an Om factory method or a React rendering function.\n\n  `props` : the React properties for the element to be loaded.\n\n  Optional:\n\n  `ready-render` : the render method to call when the desired data has been marked as ready\n  to load, but the server request has not yet been sent.\n\n  `loading-render` : render method once the server request has been sent, and UI is waiting\n  on the response\n\n  `failed-render` : render method when the server returns a failure state for the requested data\n\n  `not-present-render` : called when props is nil (helpful for differentiating between a nil and\n  empty response from the server).\n\n  Example Usage:\n\n  ```\n  (defui Thing\n    static om/IQuery\n    (query [this] [{:thing2 (om/get-query Thing2)}])\n    Object\n    (componentDidMount [this]\n       (load-field this :thing2))\n\n    (render [this]\n      (let [thing2 (:thing2 (om/props this))]\n        (lazily-loaded ui-thing2 thing2))))\n\n  (defui Thing2\n    static om/IQuery\n    (query [this] [:ui/fetch-state])\n    Object\n    (render [this]\n      (display-thing-2))\n\n  (def ui-thing2 (om/factory Thing2))\n  ```", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(data-render props {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div (js-obj "className" "lazy-loading-load") "Loading...")), ready-render (fn [_] (dom/div (js-obj "className" "lazy-loading-ready") "Queued")), failed-render (fn [_] (dom/div (js-obj "className" "lazy-loading-failed") "Loading error!"))}})], :arglists ([data-render props & {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div (js-obj "className" "lazy-loading-load") "Loading...")), ready-render (fn [_] (dom/div (js-obj "className" "lazy-loading-ready") "Queued")), failed-render (fn [_] (dom/div (js-obj "className" "lazy-loading-failed") "Loading error!"))}}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/lazily-loaded, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(data-render props {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div (js-obj "className" "lazy-loading-load") "Loading...")), ready-render (fn [_] (dom/div (js-obj "className" "lazy-loading-ready") "Queued")), failed-render (fn [_] (dom/div (js-obj "className" "lazy-loading-failed") "Loading error!"))}})], :arglists ([data-render props & {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div (js-obj "className" "lazy-loading-load") "Loading...")), ready-render (fn [_] (dom/div (js-obj "className" "lazy-loading-ready") "Queued")), failed-render (fn [_] (dom/div (js-obj "className" "lazy-loading-failed") "Loading error!"))}}]), :arglists-meta (nil)}, :method-params [(data-render props {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div (js-obj "className" "lazy-loading-load") "Loading...")), ready-render (fn [_] (dom/div (js-obj "className" "lazy-loading-ready") "Queued")), failed-render (fn [_] (dom/div (js-obj "className" "lazy-loading-failed") "Loading error!"))}})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 253, :end-line 253, :max-fixed-arity 2, :fn-var true, :arglists ([data-render props & {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div (js-obj "className" "lazy-loading-load") "Loading...")), ready-render (fn [_] (dom/div (js-obj "className" "lazy-loading-ready") "Queued")), failed-render (fn [_] (dom/div (js-obj "className" "lazy-loading-failed") "Loading error!"))}}]), :doc "Custom rendering for use while data is being lazily loaded using the data fetch methods\n  load-collection and load-field.\n\n  `data-render` : the render method to call once the data has been successfully loaded from\n  the server. Can be an Om factory method or a React rendering function.\n\n  `props` : the React properties for the element to be loaded.\n\n  Optional:\n\n  `ready-render` : the render method to call when the desired data has been marked as ready\n  to load, but the server request has not yet been sent.\n\n  `loading-render` : render method once the server request has been sent, and UI is waiting\n  on the response\n\n  `failed-render` : render method when the server returns a failure state for the requested data\n\n  `not-present-render` : called when props is nil (helpful for differentiating between a nil and\n  empty response from the server).\n\n  Example Usage:\n\n  ```\n  (defui Thing\n    static om/IQuery\n    (query [this] [{:thing2 (om/get-query Thing2)}])\n    Object\n    (componentDidMount [this]\n       (load-field this :thing2))\n\n    (render [this]\n      (let [thing2 (:thing2 (om/props this))]\n        (lazily-loaded ui-thing2 thing2))))\n\n  (defui Thing2\n    static om/IQuery\n    (query [this] [:ui/fetch-state])\n    Object\n    (render [this]\n      (display-thing-2))\n\n  (def ui-thing2 (om/factory Thing2))\n  ```"}, load-field {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 116, :column 7, :end-line 116, :end-column 17, :arglists (quote ([component field & {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]}])), :doc "Load a field of the current component. Runs `om/transact!`.\n\n  Parameters\n  - `component`: The component (**instance**, not class). This component MUST have an Ident.\n  - `field`: A field on the component's query that you wish to load.\n\n  Named Parameters:\n  - `without`: See `load-data`\n  - `params`: See `load-data`\n  - `post-mutation`: See `load-data`\n  - `parallel`: See `load-data`\n  - `fallback`: See `load-data`\n  - `marker`: See `load-data`\n  - `refresh`: See `load-data`\n\n  NOTE: The :ui/loading-data attribute is always included in refresh. This means you probably don't want to\n  query for that attribute near the root of your UI. Instead, create some leaf component with an ident that queries for :ui/loading-data\n  using an Om link (e.g. `[:ui/loading-data '_]`). The presence of the ident on components will enable query optimization, which can\n  improve your frame rate because Om will not have to run a full root query.\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(component field {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]})], :arglists ([component field & {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/load-field, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(component field {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]})], :arglists ([component field & {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]}]), :arglists-meta (nil)}, :method-params [(component field {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 116, :end-line 116, :max-fixed-arity 2, :fn-var true, :arglists ([component field & {:keys [without params post-mutation fallback parallel refresh marker], :or [refresh [] marker true]}]), :doc "Load a field of the current component. Runs `om/transact!`.\n\n  Parameters\n  - `component`: The component (**instance**, not class). This component MUST have an Ident.\n  - `field`: A field on the component's query that you wish to load.\n\n  Named Parameters:\n  - `without`: See `load-data`\n  - `params`: See `load-data`\n  - `post-mutation`: See `load-data`\n  - `parallel`: See `load-data`\n  - `fallback`: See `load-data`\n  - `marker`: See `load-data`\n  - `refresh`: See `load-data`\n\n  NOTE: The :ui/loading-data attribute is always included in refresh. This means you probably don't want to\n  query for that attribute near the root of your UI. Instead, create some leaf component with an ident that queries for :ui/loading-data\n  using an Om link (e.g. `[:ui/loading-data '_]`). The presence of the ident on components will enable query optimization, which can\n  improve your frame rate because Om will not have to run a full root query.\n  "}, load-data-action {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 210, :column 7, :end-line 210, :end-column 23, :arglists (quote ([app-state query & {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}}])), :doc "\n  Queue up a remote load from within an already-running mutation. Similar to `load-data`, but usable from\n  within a mutation.\n\n  Note the `:refresh` parameter is supported, and defaults to empty. If you want anything to refresh other than\n  the targeted component you will want to include the :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-data-action ...)\n       ; other optimistic updates/state changes)}", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(app-state query {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}})], :arglists ([app-state query & {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/load-data-action, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(app-state query {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}})], :arglists ([app-state query & {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}}]), :arglists-meta (nil)}, :method-params [(app-state query {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 210, :end-line 210, :max-fixed-arity 2, :fn-var true, :arglists ([app-state query & {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}}]), :doc "\n  Queue up a remote load from within an already-running mutation. Similar to `load-data`, but usable from\n  within a mutation.\n\n  Note the `:refresh` parameter is supported, and defaults to empty. If you want anything to refresh other than\n  the targeted component you will want to include the :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-data-action ...)\n       ; other optimistic updates/state changes)}"}, load-data {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 151, :column 7, :end-line 151, :end-column 16, :arglists (quote ([comp-or-reconciler query & {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}}])), :doc "\n  Load data from the remote. Runs `om/transact!`. See also `load-field`.\n\n  Parameters\n  - `comp-or-reconciler`: A component or reconciler (not a class)\n  - `query`: The query for the element(s) attributes. Use defui to generate arbitrary queries so normalization will work.\n\n  Optional Named parameters\n  - `post-mutation`: A mutation (symbol) invoked after the load succeeds.\n  - `fallback`: A mutation (symbol) invoked after the load fails. App state is in env, server error is in the params under :error.\n  - `parallel`: Boolean to indicate that this load should happen in the parallel on the server (non-blocking load). Any loads marked this way will happen in parallel.\n  - `marker`: A boolean (default true). If true, a marker is placed in the app state in place of the target data during the load. If false, no marker is produced.\n  - `refresh`: A vector of keywords indicating data that will be changing. If any of the listed keywords are queried by on-screen\n    components, then those components will be re-rendered after the load has finished and post mutations have run.\n  - `without`: A set of keywords. Any keyword appearing in this set will be recursively removed from the query (in a proper AST-preserving fashion).\n  - `params`: A parameter map to augment onto the first element of the query\n\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(comp-or-reconciler query {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}})], :arglists ([comp-or-reconciler query & {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/load-data, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(comp-or-reconciler query {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}})], :arglists ([comp-or-reconciler query & {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}}]), :arglists-meta (nil)}, :method-params [(comp-or-reconciler query {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 151, :end-line 151, :max-fixed-arity 2, :fn-var true, :arglists ([comp-or-reconciler query & {:keys [ident without params post-mutation fallback parallel refresh marker], :or {refresh [], marker true}}]), :doc "\n  Load data from the remote. Runs `om/transact!`. See also `load-field`.\n\n  Parameters\n  - `comp-or-reconciler`: A component or reconciler (not a class)\n  - `query`: The query for the element(s) attributes. Use defui to generate arbitrary queries so normalization will work.\n\n  Optional Named parameters\n  - `post-mutation`: A mutation (symbol) invoked after the load succeeds.\n  - `fallback`: A mutation (symbol) invoked after the load fails. App state is in env, server error is in the params under :error.\n  - `parallel`: Boolean to indicate that this load should happen in the parallel on the server (non-blocking load). Any loads marked this way will happen in parallel.\n  - `marker`: A boolean (default true). If true, a marker is placed in the app state in place of the target data during the load. If false, no marker is produced.\n  - `refresh`: A vector of keywords indicating data that will be changing. If any of the listed keywords are queried by on-screen\n    components, then those components will be re-rendered after the load has finished and post mutations have run.\n  - `without`: A set of keywords. Any keyword appearing in this set will be recursively removed from the query (in a proper AST-preserving fashion).\n  - `params`: A parameter map to augment onto the first element of the query\n\n  "}, remote-load {:protocol-inline nil, :meta {:file "/Users/michaelgough/untangled-cookbook/recipes/websockets/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 238, :column 7, :end-line 238, :end-column 18, :arglists (quote ([parsing-env])), :doc "Returns the correct value for the `:remote` side of a mutation that should act as a\n  trigger for remote loads. Must be used in conjunction with running `load-data-action` or\n  `load-data-field` in the `:action` side of the mutation (which queues the exact things to\n  load)."}, :name untangled.client.data-fetch/remote-load, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 18, :method-params ([parsing-env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 238, :end-line 238, :max-fixed-arity 1, :fn-var true, :arglists (quote ([parsing-env])), :doc "Returns the correct value for the `:remote` side of a mutation that should act as a\n  trigger for remote loads. Must be used in conjunction with running `load-data-action` or\n  `load-data-field` in the `:action` side of the mutation (which queues the exact things to\n  load)."}}, :require-macros {om om.next, om.next om.next, untangled.i18n untangled.i18n, dom om.dom, om.dom om.dom}, :cljs.analyzer/constants {:seen #{:key :refresh :else :not-present-render :ui/fetch-state :parallel :fallback :marker :reconciler :params untangled/load :ast :field :state :post-mutation :without :failed-render :ident :dispatch-key :loading-render :post-mutation-params :ready-render :ui/loading-data :target :query}, :order [:target :params :marker :refresh :parallel :post-mutation :post-mutation-params :fallback :without :query untangled/load :ui/loading-data :reconciler :state :field :ident :ast :key :dispatch-key :ready-render :loading-render :failed-render :not-present-render :ui/fetch-state :else]}, :doc nil}